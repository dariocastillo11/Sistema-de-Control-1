# -*- coding: utf-8 -*-
"""SistemaDeComunicacionConFuncionBasePulsoRectangular- CLASE 7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wB7-CwRvovZnfe03su1a_fe0lfRal1SF
"""

#------------------------------- Libraries -------------------------------

import adi
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import welch

#------------------------------- SDR Parameter Configuration -------------------------------

Uri              = "ip:192.168.1.32"
SamplingRate     = 4e6           # Sample rate RX and TX paths[Samples/Sec]
Loopback         = 0             # 0=Disabled, 1=Digital, 2=RF

TxLOFreq         = int(945e6)         # Carrier frequency of TX path [Hz] RELLENAR CON LA FREC. DE PORTADORA ASIGNADA
TxAtten          = -60           # Attenuation applied to TX path, valid range is -90 to 0 dB [dB]
TxRfBw           = SamplingRate           # Bandwidth of front-end analog filter of TX path [Hz]

RxLOFreq         = TxLOFreq      # Carrier frequency of RX path [Hz]
GainControlModes = "manual" # Receive path AGC Options: slow_attack, fast_attack, manual
RxHardwareGain   = 70             # Gain applied to RX path. Only applicable when gain_control_mode is set to 'manual'
RxRfBw           = TxRfBw        # Bandwidth of front-end analog filter of RX path [Hz]

z = np.random.uniform(size=2**16)
x=[1 if z[i]>0.5 else 0 for i in range(len(z)) ]

signal = (2*np.repeat(x ,2**4)-1)+1j*(2*np.repeat(x , 2**4)-1)

#------------------------------- Received I component -------------------------------
# Plot time domain
plt.figure(figsize=(20,8), dpi= 80, facecolor='w', edgecolor='k')
plt.subplot(2,1,1)
plt.plot(np.real(signal[0:1500]), '.-')
plt.xlabel('n')
plt.ylabel('Amplitud')
plt.title('Una parte de la componente I de la señal recibida')
plt.grid()

#------------------------------- Received Q component -------------------------------
# Plot time domain
plt.subplot(2,1,2)
plt.plot(np.imag(signal[0:1500]), '.-C1')
plt.xlabel('n')
plt.ylabel('Amplitud')
plt.title('Una parte de la componente Q de la señal recibida')
plt.grid()
plt.show()

RxBufferSize     = len(signal)

#------------------------------- SDR Setup -------------------------------

sdr             = adi.Pluto(Uri)
sdr.sample_rate = SamplingRate
sdr.loopback    = Loopback
#Tx:
sdr.tx_lo                 = int(TxLOFreq)
sdr.tx_hardwaregain_chan0 = TxAtten
sdr.tx_rf_bandwidth       = int(TxRfBw)
sdr.tx_cyclic_buffer      = False
# Rx:
sdr.rx_lo                   = int(RxLOFreq)
sdr.gain_control_mode_chan0 = GainControlModes
sdr.rx_hardwaregain_chan0   = RxHardwareGain
sdr.rx_rf_bandwidth         = int(RxRfBw)
sdr.rx_cyclic_buffer        = False
sdr.rx_buffer_size          = RxBufferSize

sdr.tx(signal*(2**14))

rxSignal = sdr.rx()

pot = np.var(rxSignal)
norm = np.sqrt(np.sum(np.abs(rxSignal)**2)/SamplingRate)*2
rxSignal = np.sqrt(2)*rxSignal/np.sqrt(pot)#/norm #

#------------------------------- Received I component -------------------------------
# Plot time domain
plt.figure(figsize=(20,8), dpi= 80, facecolor='w', edgecolor='k')
plt.subplot(2,1,1)
plt.plot(np.real(rxSignal[0:800]), '.-')
plt.xlabel('n')
plt.ylabel('Amplitud')
plt.title('Una parte de la componente I de la señal recibida')
plt.grid()

#------------------------------- Received Q component -------------------------------
# Plot time domain
plt.subplot(2,1,2)
plt.plot(np.imag(rxSignal[0:800]), '.-C1')
plt.xlabel('n')
plt.ylabel('Amplitud')
plt.title('Una parte de la componente Q de la señal recibida')
plt.grid()
plt.show()

#import matplotlib.pyplot as plt

def calcular_psd(senal, fs, nperseg=1024, plotear=True):
    #Calcula la densidad espectral de potencia (PSD) de una señal utilizando el método de Welch.

    is_complex = np.iscomplexobj(senal)

    f, Pxx = welch(senal, fs=fs, nperseg=nperseg, return_onesided=not is_complex)

    if plotear:
        plt.figure(figsize=(20,8), dpi= 80, facecolor='w', edgecolor='k')
        #plt.figure(figsize=(8, 4))
        plt.plot(f, 10 * np.log10(Pxx))  # dB scale
        plt.title('Densidad Espectral de Potencia (PSD)')
        plt.xlabel('Frecuencia [Hz]')
        plt.ylabel('PSD [dB/Hz]')
        plt.grid(True)
        plt.tight_layout()
        plt.show()

    return f, Pxx

# Calcular PSD
frecuencias, psd = calcular_psd(rxSignal, SamplingRate)

# Since it is not possible to turn off Tx, it is configured to transmit at low power and on a different frequency than Rx.
sdr.tx_destroy_buffer()
sdr.tx_hardwaregain_chan0  = -70
sdr.rx_lo                  = int(2400e6)
sdr.tx(np.zeros(1024))

# Destroy radio object
del(sdr)

"""# PRACTICO 7
# TRANSMISOR

#### GENERADOR DE HIPOTESIS
"""

import numpy as np
import matplotlib.pyplot as plt
def generadordeBits(N):
    return np.random.randint(0,2,N)


print(generadordeBits(10))

"""#### CODIFICADOR"""

def codificador(bits_generados):
    y=[]
    y = 2*bits_generados-1
    return y

print(codificador(10))

"""#### FORMA DE ONDA"""

def waveform(simbolos, T=16, tipo='rectangular', beta=0.25, sps=16):
    if tipo == 'rectangular':
        funcion_base = np.ones(T)
    elif tipo == 'rrc':
        funcion_base = generar_pulso_rrc(beta, 1, sps, N=6)
    else:
        raise ValueError("Tipo de función base no reconocida.")

    señal_tx = np.convolve(np.repeat(simbolos, len(funcion_base)), funcion_base, mode='full')
    return señal_tx

"""# CANAL
#### RUIDO BLANCO GAUSEANO
"""

def paso_por_el_canal(señal,varianza=1,ideal=False):
    if ideal:
        return señal
    ruido=np.random.normal(0,varianza,len(señal))
    return señal+ruido

"""# RECEPTOR

####  n-Tuple Former del tipo correlado
"""

def ntupleformer_correlacion(señal_tx,T=16):
    resultados=[]
    for i in range(0,len(señal_tx),T):
        bloque=señal_tx[i:i+T]
        if len(bloque)<T:
            break
        correlacion=np.sum(bloque*1)
        resultados.append(correlacion)

    return np.array(resultados)

"""####  n-Tuple Former del tipo matched filte"""

def ntupleformer_matchedfilter(señal_tx,T=16):
    base = np.ones(T)
    salida = np.convolve(señal_tx, base[::-1], mode='full')
    resultados = salida[T-1::T]
    return resultados

"""#### DECODER TIPO - MAP"""

def decod_MAP(simbolos_ntupleformer, varianza=1):
    bits = []

    for simbolo in simbolos_ntupleformer:
        p_mas = np.exp(-(simbolo - 1)**2 / (2 * varianza**2))
        p_menos = np.exp(-(simbolo + 1)**2 / (2 * varianza**2))

        if p_mas > p_menos:
            bits.append(1)
        else:
            bits.append(0)

    return bits

"""#### DECODER TIPO - ML"""

def decod_ML(simbolos_ntupleformer):
  bits=[]
  for simbolos in simbolos_ntupleformer:
    if simbolos>0:
      bits.append(1)
    else:
      bits.append(0)
  return bits

"""# ERROR

#### PRUEBA BER
"""

def calcular_BER(bits_originales, bits_estimados):
    errores = 0
    for b1, b2 in zip(bits_originales, bits_estimados):
        if b1 != b2:
            errores += 1
    return errores / len(bits_originales)
print()

"""### prueba de sistema de comunicaciones

"""

N_bits=10
T=16
varianza=1
ideal=True
bits = generadordeBits(N_bits)
print("bits")
print(bits)
print("\n")


simbolos = codificador(bits)
print("simbolos")
print(simbolos)
print("\n")

señal_tx = waveform(simbolos, T=16, tipo='rrc', beta=0.25, sps=16) ##Se puede seleccionar el tipo a "rectangular" tambien
print("señal_txt")
print(señal_tx)
print("\n")

señal_tx_ruido = paso_por_el_canal(señal_tx,varianza,ideal)
print("señal_tx_ruido")
print(señal_tx_ruido)
print("\n")

señal_rx_correlador=ntupleformer_correlacion(señal_tx_ruido,T)
print("señal_rx_correlador")
print(señal_rx_correlador)
print("\n")

señal_rx_matchedfilter=ntupleformer_matchedfilter(señal_tx_ruido,T)
print("señal_rx_matchedfilter")
print(señal_rx_matchedfilter)
print("\n")

bits_MAP1=decod_MAP(señal_rx_correlador,varianza)
print("bits_MAP1")
print(bits_MAP1)
print("\n")

bits_MAP2=decod_MAP(señal_rx_matchedfilter)
print("bits_MAP2")
print(bits_MAP2)
print("\n")


bits_ML1=decod_ML(señal_rx_correlador)
print("bits_ML1")
print(bits_ML1)
print("\n")

bits_ML2=decod_ML(señal_rx_matchedfilter)
print("bits_ML2")
print(bits_ML2)
print("\n")

BER=calcular_BER(bits,bits_ML1)
print("BER")
print(BER)
print("\n")


########################
# Parámetros de ejemplo
simbolos = [1, -1, 1, 1, -1]
T = 16
tipo = 'rrc'  # o 'rectangular'
beta = 0.25
sps = 16

# Señales
señal_tx = waveform(simbolos, T=T, tipo=tipo, beta=beta, sps=sps)
señal_rx = paso_por_el_canal(señal_tx, varianza=0.05)



# Eje de tiempo
t = np.arange(len(señal_tx))

# Gráfico
plt.plot(t, señal_tx, label='Transmitida (sin ruido)')
plt.xlabel('Muestras')
plt.ylabel('Amplitud')
plt.title('Forma de Onda Transmitida')
plt.legend()
plt.grid()
plt.show()
# Eje de tiempo
t = np.arange(len(señal_tx))

# Gráfico
plt.plot(t, señal_tx, label='Transmitida (sin ruido)')
plt.plot(t, señal_rx, label='Recibida (con ruido)', linestyle='--')
plt.xlabel('Muestras')
plt.ylabel('Amplitud')
plt.title('Forma de Onda TX y RX')

"""# PRACTICO 8- DEFINICION DE RRC RAIZ COSENO REALZADO:"""

def generar_pulso_rrc(beta, T, sps, N):


    t = np.linspace(-N/2*T, N/2*T, N*sps)  # eje de tiempo
    h = np.zeros_like(t)

    for i in range(len(t)):
        if t[i] == 0.0:
            h[i] = 1.0 - beta + (4 * beta / np.pi)
        elif abs(t[i]) == T / (4 * beta):
            h[i] = (beta / np.sqrt(2)) * (
                (1 + 2 / np.pi) * np.sin(np.pi / (4 * beta)) +
                (1 - 2 / np.pi) * np.cos(np.pi / (4 * beta))
            )
        else:
            num = (np.sin(np.pi * t[i] * (1 - beta) / T) +
                   4 * beta * t[i] / T * np.cos(np.pi * t[i] * (1 + beta) / T))
            denom = (np.pi * t[i] * (1 - (4 * beta * t[i] / T) ** 2))
            h[i] = num / denom

    # Normalizar energía
    h = h / np.sqrt(np.sum(h ** 2))
    return h

"""# PRUEBA DEL SISTEMA DE COMUNICACIONES"""

N_bits=10
T=16
varianza=1
ideal=True
bits = generadordeBits(N_bits)
print("bits")
print(bits)
print("\n")


simbolos = codificador(bits)
print("simbolos")
print(simbolos)
print("\n")

señal_tx = waveform(simbolos, T=16, tipo='rrc', beta=0.25, sps=16) ##Se puede seleccionar el tipo a "rectangular" tambien
print("señal_txt")
print(señal_tx)
print("\n")

señal_tx_ruido = paso_por_el_canal(señal_tx,varianza,ideal)
print("señal_tx_ruido")
print(señal_tx_ruido)
print("\n")

señal_rx_correlador=ntupleformer_correlacion(señal_tx_ruido,T)
print("señal_rx_correlador")
print(señal_rx_correlador)
print("\n")

señal_rx_matchedfilter=ntupleformer_matchedfilter(señal_tx_ruido,T)
print("señal_rx_matchedfilter")
print(señal_rx_matchedfilter)
print("\n")

bits_MAP1=decod_MAP(señal_rx_correlador,varianza)
print("bits_MAP1")
print(bits_MAP1)
print("\n")

bits_MAP2=decod_MAP(señal_rx_matchedfilter)
print("bits_MAP2")
print(bits_MAP2)
print("\n")


bits_ML1=decod_ML(señal_rx_correlador)
print("bits_ML1")
print(bits_ML1)
print("\n")

bits_ML2=decod_ML(señal_rx_matchedfilter)
print("bits_ML2")
print(bits_ML2)
print("\n")

BER=calcular_BER(bits,bits_ML1)
print("BER")
print(BER)
print("\n")
print("señal")
###########################
beta = 0.35
T = 1
sps = 100
N = 6

# Generar señales
h = generar_pulso_rrc(beta, T, sps, N)
h_ruido = paso_por_el_canal(h, varianza=0.05)

# Eje de tiempo
t = np.linspace(-N/2*T, N/2*T, N*sps)

# Gráfico
plt.plot(t, h, label='Señal sin ruido')
plt.xlabel('Tiempo')
plt.ylabel('Amplitud')
plt.title('Pulso RRC (sin ruido)')
plt.legend()
plt.grid()
plt.show()

# Eje de tiempo
t = np.linspace(-N/2*T, N/2*T, N*sps)

# Gráfico
plt.plot(t, h, label='Original')
plt.plot(t, h_ruido, label='Con Ruido', linestyle='--')
plt.xlabel('Tiempo')
plt.ylabel('Amplitud')
plt.title('Pulso RRC')
plt.legend()
plt.grid()
plt.show()













